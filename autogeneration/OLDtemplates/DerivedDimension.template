#ifndef STATIC_DIMENSION_{{ dim.name.upper() }}_IMPL_H
#define STATIC_DIMENSION_{{ dim.name.upper() }}_IMPL_H

{%- macro pre_and_post(type_list, prefix, suffix, before_first=true, after_last=true, delimiter='') -%}
  {%- for item in type_list -%}
    {%- if loop.first and not before_first -%}
      {%- set pre = '' -%}
    {%- else -%}
      {%- set pre = prefix -%}
    {%- endif -%}
    {%- if loop.last and not after_last -%}
      {%- set post = '' -%}
    {%- else -%}
      {%- set post = suffix -%}
    {%- endif -%}
    {%- if not loop.last -%}
      {%- set post = post+delimiter -%}
    {%- endif -%}
    {{ pre }}{{ item }}{{ post }}
  {%- endfor -%}
{%- endmacro -%}

{%- macro prepend_typename(type_list) -%}
{{ pre_and_post(type_list, 'typename ', ', ', true, false) }}
{%- endmacro -%}

{%- macro type_line(modifier=do_nothing) -%}
{{ prepend_typename(dim.num.list_numbered + dim.den.list_numbered) }}
{%- endmacro -%}

{%- macro template_line(indent_count=0) -%}
{%- set indent_space = 3 * indent_count -%}
{%- filter indent(width=indent_space) -%}
template<{{ type_line() }}>
{%- endfilter -%}
{%- endmacro -%}

{%- macro doxygen_types(indent_count=0) -%}
{%- set indent_space = 3 * indent_count -%}
  {%- set lines = [] -%}
  {%- for item in dim.num.list_numbered -%}
    {%- set _ = lines.append(" "*indent_space ~ "/// @tparam " ~ item ~ " Numerator " ~ item ~ " type") -%}
  {%- endfor -%}
  {%- for item in dim.den.list_numbered -%}
    {%- set _ = lines.append(" "*indent_space ~ "/// @tparam " ~ item ~ " Denominator " ~ item ~ " type") -%}
  {%- endfor -%}
  {{ lines | join("\n") }}
{%- endmacro %}

{%- macro primary_tuples() -%}
std::tuple<{% if dim.num.list_numbered -%} Primary {%- endif %}{{ dim.num.list | map('string') | join(', Primary') }}>, std::tuple<{% if dim.den.list_numbered -%} Primary {%- endif %}{{ dim.den.list | map('string') | join(', Primary') }}>
{%- endmacro %}

{%- macro is_unit() -%}
Is{{ dim.name }}Units<
{%- for item in dim.num.list_numbered -%}
typename std::tuple_element_t<{{ loop.index -1 }}, typename T::NumTuple>{% if not loop.last %}, {% endif %}
{%- endfor -%}
{%- if dim.num.list_numbered and dim.den.list_numbered -%}, {% endif -%}
{%- for item in dim.den.list_numbered -%}
typename std::tuple_element_t<{{ loop.index -1 }}, typename T::DenTuple>{% if not loop.last %}, {% endif %}
{% endfor -%}
>;
{%- endmacro %}

{%- macro dim_list() -%}
{{ pre_and_post(dim.num.list_numbered, '', ', ', false, false) }}
{%- if dim.num.list_numbered and dim.den.list_numbered -%}, {% endif -%}
{{ pre_and_post(dim.den.list_numbered, '', ', ', false, false) }}
{%- endmacro %}

{%- macro dim_tuples() -%}
std::tuple<
{{- pre_and_post(dim.num.list_numbered, '', ', ', false, false) -}}
>, std::tuple<
{{- pre_and_post(dim.den.list_numbered, '', ', ', false, false) -}}
>
{%- endmacro %}

{%- macro dim_listT() -%}
{{ pre_and_post(dim.num.list_numbered, '', 'T', false, true, ', ') }}
{%- if dim.num.list_numbered and dim.den.list_numbered -%}, {% endif -%}
{{ pre_and_post(dim.den.list_numbered, '', 'T', false, true, ', ') }}
{%- endmacro %}

{%- macro dim_list_typenameT() -%}
{{ pre_and_post(dim.num.list_numbered, 'typename ', 'T', true, true, ', ') }}
{%- if dim.num.list_numbered and dim.den.list_numbered -%}, {% endif -%}
{{ pre_and_post(dim.den.list_numbered, 'typename ', 'T', true, true, ', ') }}
{%- endmacro %}

{%- macro dimension_checks(indent_count=0) -%}
{%- set indent_space = 3 * indent_count -%}
{%- filter indent(width=indent_space) -%}
{%- set num_items = [] %}
{%- set den_items = [] %}
{% for n in range(dim.num.size) %}
{% set item = "typename " + dim.num.list_numbered[n] + "::Dim, " + dim.num.list[n] + "Type" %}
{% set num_items = num_items.append(item) %}
{% endfor %}
{% for n in range(dim.den.size) %}
{% set item = "typename " + dim.den.list_numbered[n] + "::Dim, " + dim.den.list[n] + "Type" %}
{% set den_items = den_items.append(item) %}
{% endfor %}
{{ pre_and_post(num_items+den_items, 'std::is_same_v<', '>', true, true, ' &&\n' ) }};
{%- endfilter -%}
{%- endmacro %}


{{ pre_and_post(dim.num.unique_dims, '#include "../../', 'Dimension.h"', true, true, '\n') }}
{{ pre_and_post(dim.den.unique_dims, '#include "../../', 'Dimension.h"', true, true, '\n') }}

namespace dimension
{
   /// @brief Concept for a named {{ dim.name }} unit.
   /// @tparam Named{{ dim.name }} The type to be checked as a named {{ dim.name }} unit.
   template<typename Named{{ dim.name }}>
   concept IsNamed{{ dim.name }}Unit = requires {
      typename Named{{ dim.name }}::NumTuple;
      typename Named{{ dim.name }}::DenTuple;
   };

   /// @brief Concept for a {{ dim.name }} dimension.
   /// @details Checks if the provided types satisfy the {{ dim.name }} dimension requirements.
{{ doxygen_types(1) }}
   {{ template_line(1) }}
   concept Is{{ dim.name }}Units = 
      {{ dimension_checks(2) }}

   /// @brief Concept for a {{ dim.name }} type.
   /// @details Ensures that the type meets {{ dim.name }} type requirements, based on numerator and denominator types.
   /// @tparam T The type to validate.
   template<typename T>
   concept Is{{ dim.name }}Type = requires {
      typename T::NumTuple;
      typename T::DenTuple;
   } && std::tuple_size_v<typename T::NumTuple> == {{ dim.num.size }} && std::tuple_size_v<typename T::DenTuple> == {{ dim.den.size }} &&
   {{ is_unit() }}

   /// @brief Retrieves the value of a {{ dim.name }} object.
   /// @details Provides access to the underlying value represented by a {{ dim.name }} object.
{{ doxygen_types(1) }}
   /// @tparam {{ dim.name }}Type The type of the object being accessed.
   /// @param obj The {{ dim.name }} object.
   /// @return The underlying value as `PrecisionType`
   template<{{ type_line() }}, typename {{ dim.name }}Type>
   requires Is{{ dim.name }}Units<{{ dim_list() }}> && Is{{ dim.name }}Type<{{ dim.name }}Type>
   constexpr PrecisionType get{{ dim.name }}(const {{ dim.name }}Type& obj)
   {
      return obj.template GetVal<{{ dim_tuples() }}>();
   }

   /// @brief Retrieves the value of a named {{ dim.name }} object.
   /// @details Provides access to the value represented by a named {{ dim.name }} object.
   /// @tparam Named{{ dim.name }} The named unit type.
   /// @tparam {{ dim.name }}Type The type of the object being accessed.
   /// @param obj The {{ dim.name }} object.
   /// @return The underlying value as `PrecisionType`.
   template<typename Named{{ dim.name }}, typename {{ dim.name }}Type>
   requires IsNamed{{ dim.name }}Unit<Named{{ dim.name }}> && Is{{ dim.name }}Type<{{ dim.name }}Type>
   constexpr PrecisionType get{{ dim.name }}(const {{ dim.name }}Type& obj)
   {
      return obj.template GetVal<typename Named{{ dim.name }}::NumTuple, typename Named{{ dim.name }}::DenTuple>();
   }

   template<typename... Ts>
   class {{ dim.name }};

   /// @brief Represents a default {{ dim.name }}.
   /// @details This {{ dim.name }} is templated on the primary units of the relevant dimensions.
   ///   While this is a specific type, its intended use is to treat an object or parameter as an abstract
   ///   "{{ dim.name }}" type, without regard for the underlying units.
   template<>
   class {{ dim.name }}<> : public base_dimension<{{ primary_tuples() }}>
   {
   public:
      using Base = base_dimension<{{ primary_tuples() }}>;
      using Base::Base;

      /// @brief Constructs a {{ dim.name }} object with a value.
      /// @param val The value of the {{ dim.name }}.
      explicit constexpr {{ dim.name }}(PrecisionType val) : Base(val) {}

      /// @brief Constructs a {{ dim.name }} object from another {{ dim.name }} object.
      /// @tparam Other{{ dim.name }} The other {{ dim.name }} type.
      /// @param base The base {{ dim.name }} object.
      template<typename Other{{ dim.name }}>
      requires Is{{ dim.name }}Type<Other{{ dim.name }}>
      // Implicit conversion between dimensions of the same unit is core to Dimensional
      // cppcheck-suppress noExplicitConstructor
      constexpr {{ dim.name }}(const Other{{ dim.name }}& base)
         : Base(base.template GetVal<{{ primary_tuples() }}>()) {}
   };

   /// @brief Represents a {{ dim.name }}.
   /// @details Defines operations and data storage for {{ dim.name }} dimensions.
{{ doxygen_types(1) }}
   {{ template_line(1) }}
   requires Is{{ dim.name }}Units<{{ dim_list() }}>
   class {{ dim.name }}<{{ dim_list() }}> : public base_dimension<{{ dim_tuples() }}>
   {
   public:
      using Base = base_dimension<{{ dim_tuples() }}>;
      using Base::Base;

      /// @brief Constructs a {{ dim.name }} object with a value.
      /// @param val The value of the {{ dim.name }}.
      explicit constexpr {{ dim.name }}(PrecisionType val) : Base(val) {}

      /// @brief Constructs a {{ dim.name }} object from a named unit.
      /// @tparam Named{{ dim.name }} The named unit type.
      /// @param base The base unit object.
      template<typename Named{{ dim.name }}>
      requires IsNamed{{ dim.name }}Unit<Named{{ dim.name }}>
      // Implicit conversion between dimensions of the same unit is core to Dimensional
      // cppcheck-suppress noExplicitConstructor
      constexpr {{ dim.name }}(const Named{{ dim.name }}& base) : Base(base) {}

      /// @brief Deprecated function to get the value of {{ dim.name }}.
      /// @details Prefer using the free function `get{{ dim.name }}()` instead.
      /// @return The value of the {{ dim.name }}.
      template<{{ dim_list_typenameT() }}>
      requires Is{{ dim.name }}Units<{{ dim_listT() }}>
      [[deprecated("Use the free function get{{ dim.name }}() instead.")]]
      // cppcheck-suppress unusedFunction
      double Get{{ dim.name }}() const
      {
         return get{{ dim.name }}<{{ dim_listT() }}>(*this);
      }

      /// @brief Deprecated function to get the value of {{ dim.name }}.
      /// @details Prefer using the free function `get{{ dim.name }}()` instead.
      /// @return The value of the {{ dim.name }}.
      template<typename Named{{ dim.name }}>
      requires IsNamed{{ dim.name }}Unit<Named{{ dim.name }}>
      [[deprecated("Use the free function get{{ dim.name }}() instead.")]]
      // cppcheck-suppress unusedFunction
      double Get{{ dim.name }}() const
      {
         return get{{ dim.name }}<Named{{ dim.name }}>(*this);
      }
   };

   /// @brief Represents a named {{ dim.name }} class.
   /// @details Provides functionality for named {{ dim.name }} units.
   /// @tparam Named{{ dim.name }} The named unit type.
   template<typename Named{{ dim.name }}>
   requires IsNamed{{ dim.name }}Unit<Named{{ dim.name }}>
   class {{ dim.name }}<Named{{ dim.name }}> : public base_dimension<typename Named{{ dim.name }}::NumTuple, typename Named{{ dim.name }}::DenTuple>
   {
   public:
      using Base = base_dimension<typename Named{{ dim.name }}::NumTuple, typename Named{{ dim.name }}::DenTuple>;
      using Base::Base;

      /// @brief Constructs a {{ dim.name }} object with a value.
      /// @param val The value of the {{ dim.name }}.
      explicit constexpr {{ dim.name }}(PrecisionType val) : Base(val) {}

      /// @brief Constructs a {{ dim.name }} object from another {{ dim.name }} object.
      /// @tparam Other{{ dim.name }} The other {{ dim.name }} type.
      /// @param base The base {{ dim.name }} object.
      template<typename Other{{ dim.name }}>
      requires Is{{ dim.name }}Type<Other{{ dim.name }}>
      // Implicit conversion between dimensions of the same unit is core to Dimensional
      // cppcheck-suppress noExplicitConstructor
      constexpr {{ dim.name }}(const Other{{ dim.name }}& base)
         : Base(base.template GetVal<typename Named{{ dim.name }}::NumTuple, typename Named{{ dim.name }}::DenTuple>()) {}

      /// @brief Deprecated function to get the value of {{ dim.name }}.
      /// @details Prefer using the free function `get{{ dim.name }}()` instead.
      /// @return The value of the {{ dim.name }}.
      template<{{ dim_list_typenameT() }}>
      requires Is{{ dim.name }}Units<{{ dim_listT() }}>
      [[deprecated("Use the free function get{{ dim.name }}() instead.")]]
      // cppcheck-suppress unusedFunction
      double Get{{ dim.name }}() const
      {
         return get{{ dim.name }}<{{ dim_listT() }}>(*this);
      }

      /// @brief Deprecated function to get the value of {{ dim.name }}.
      /// @details Prefer using the free function `get{{ dim.name }}()` instead.
      /// @return The value of the {{ dim.name }}.
      template<typename Named{{ dim.name }}Unit>
      requires IsNamed{{ dim.name }}Unit<Named{{ dim.name }}Unit>
      [[deprecated("Use the free function get{{ dim.name }}() instead.")]]
      // cppcheck-suppress unusedFunction
      double Get{{ dim.name }}() const
      {
         return get{{ dim.name }}<Named{{ dim.name }}Unit>(*this);
      }         
   };

   /// @brief Template deduction guide for {{ dim.name }}.
{{ doxygen_types(1) }}
   {{ template_line(1) }}
   requires Is{{ dim.name }}Units<{{ dim_list() }}>
   {{ dim.name }}({{ dim_list() }}) -> {{ dim.name }}<{{ dim_list() }}>;

   /// @brief Template deduction guide for {{ dim.name }}.
{{ doxygen_types(1) }}
   template<typename Named{{ dim.name }}>
   requires IsNamed{{ dim.name }}Unit<Named{{ dim.name }}>
   {{ dim.name }}(Named{{ dim.name }}) -> {{ dim.name }}<Named{{ dim.name }}>;

   /// @brief Template deduction guide for {{ dim.name }}.
{{ doxygen_types(1) }}
   {{ template_line(1) }}
   requires Is{{ dim.name }}Units<{{ dim_list() }}>
   {{ dim.name }}(base_dimension<{{ dim_tuples() }}>) -> {{ dim.name }}<{{ dim_list() }}>;

}

#endif // STATIC_DIMENSION_{{ dim.name.upper() }}_IMPL_H